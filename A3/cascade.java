//University of Victoria
//Samuel Navarrete
//CSC485 A1 Q2, Diameter of a Network Graph

import java.io.File; 
import java.io.FileNotFoundException; 
import java.util.*;

public class cascade{
	//Parses a file with a graph in .csv format and generates an adjacency list
	public static float[][] parseFile(String filepath)
	{
		File file = new File(filepath);
		float[][] graph; 
		int size = 0; 

		try{
			Scanner sc = new Scanner(file); 
			String line = sc.nextLine(); 

			//First line of the CSV files generated by Gephi
			//contain a list of all the nodes
			String[] nodelist = line.split(";");
			size = nodelist.length-1; //graph size = # of nodes

			//To store the graph
			graph = new float[size+1][size+1];

			for(int i = 0; i < size; i++)
			{
				line = sc.nextLine(); 
				String[] nodes = line.split(";");

				for(int j = 0; j < size; j++)
				{
					graph[i][j] = Float.parseFloat(nodes[j+1]); 
				}
			}

			//Adding the supernode
			for(int i = 0; i < size; i++){
				graph[size][i] = 1;
				graph[i][size] = 1;
			}
		}

		catch (FileNotFoundException e)
		{
			graph = null; 
			System.out.println("File IO Error: could not read file");
		}

		return graph; 
	}

	public static Boolean[] createAdoptGraph(float[][] graph)
	{
		Boolean[] adopt = new Boolean[graph[0].length];
		for(int i = 0; i < graph[0].length; i++){
			adopt[i] = false; 
		}
		return adopt; 
	}

	public static int startCascade(float[][] graph, int x, float q)
	{
		Boolean[] adopt; 
		adopt = createAdoptGraph(graph); 

		//Spread budget 
		for(int i = 0; i < x; i++){
			adopt[i] = true; 
		}

		int ret_val = 0; 
		float p = 0; 


		boolean graph_changed = true; 
		while(graph_changed) // Keep going until graph stops changing
		{
			graph_changed = false; 
			for(int i = 0; i < graph[0].length; i++){
				if(adopt[i] == false){
					int neighbour_count = 0; 
					int adpt_neighbours = 0; //adopting neighbours
					for(int j = i+1; j < graph[0].length; j++){
						if(graph[i][j] == 1 || graph[j][i] == 1){
							neighbour_count++; 
							if(adopt[j] == true){
								adpt_neighbours++;
							}
						}
					}
					p = (float)((float)adpt_neighbours/(float)neighbour_count); 
					if(p >= q){
						adopt[i] = true; 
						graph_changed = true; 
						ret_val++; 
					}
				}
			}
		}
		return ret_val; 
	}

	public static void printAdjMatrix(float[][] graph){
		for(int i = 0; i < graph[0].length; i++){
			for(int j = 0; j < graph[0].length; j++){
				System.out.print((int)graph[i][j]);
			}
			System.out.println(); 
		}
	}

	public static void main(String[] args)
	{
		String filepath;  //Path of file to open
		float[][] graph;  //Adjacency matrix of graph

		float q = 0.2f; 

		//User Input
		if(args.length < 1){
			Scanner in = new Scanner(System.in);
			System.out.println("Enter path of .csv file: ");
			filepath = in.nextLine(); 
		}
		else{
			filepath = args[0];
		}


		//Generate Adjacency Matrix of graph from file
		if((graph = parseFile(filepath)) == null){
			System.out.println("Error parsing file, aborting.");
			return; 
		} 		

		for(int i = 0; i <= graph[0].length; i++){
			int total_adopt = i + startCascade(graph, i, q); 
			System.out.println("x: " + String.format("%3d", i) + " , total after: " + total_adopt); 
		}

	}
}